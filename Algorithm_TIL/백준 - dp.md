**[백준 - 구현]<https://mosobamboo-dev.tistory.com/44>**

## 10844 : 쉬운 계단 수 
- dp문제인데, 기존의 문제들과 다르게 dp 테이블을 2차원 리스트로 정의를 했어야 했다. 2차원 리스트를 **dp[자리 수][앞에 오는 숫자] = 경우의 수**
라고 정의했다. 이렇게 **필요에 따라 정의하는 능력 기르기** 
- 이후 각각의 경우 (앞에 오는 숫자에 따라서 경우의 수를 나누고 점화식 각각 정의)
- 
```
N = int(input())
dp = [[0]*10 for _ in range(N+1)]
for i in range(1, 10):
	dp[1][i] = 1 

MOD = 1000000000
for i in range(2, N+1):
	for j in range(10):
    	if j == 0: # 앞에 오는 숫자가 0일 경우 
        	dp[i][j] = dp[i-1][1] # dp[자리 수][0] = dp[자리 수 - 1][1]
        elif j == 9: # 앞에 오는 숫자가 9인 경우
        	dp[i][j] = dp[i-1][8] # dp[자리 수][앞에 오는 숫자] = dp[자리 수 - 1][앞에 오는 숫자 -1] + dp[자리 수 - 1][앞에 오는 숫자 + 1]
        else:  # 앞에 오는 숫자 = 1 ~ 8
        	dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]  # dp[자리 수][9] = dp[자리 수 - 1][8]

print(sum(dp[N]) % MOD)
```

## 9096 : 1, 2, 3 더하기
- 전형적인 DP문제. DP는 무조건 점화식 + 규칙 찾아서 DP 테이블 갱신하는 것이지만, 규칙성을 찾지 못했음. 연속된 세 항의 합이지만 n > 3 일때부터 적용되는 것이기 때문에 찾지 못했던 것 같다. (n = 2에서 멈춤)

```
# 보텀업 방식의 DP
n = int(input())
arr = []
for i in range(n):
  arr.append(int(input()))
  
# dp 테이블
d = [0] * 11
d[1] = 1
d[2] = 2
d[3] = 4

# 점화식에 의한 계산
for i in range(4, 11):
  d[i] = d[i-1] + d[i-2] + d[i-3] 

# 출력하는 부분
for j in arr:
  print(d[int(j)])
```
