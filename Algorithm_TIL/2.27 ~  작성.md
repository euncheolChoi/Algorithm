## [2/27]

#### 이코테 page98

- 리스트의 원소 자체에 바로 min(), max()함수를 사용이 가능하다  
**예시**
```
for i in range(n):
  data = list(map(int, input().split()))
  min_value = 10001
  for a in data:
    min_value = min(min_value, a)
```
#### 이코테 page101

- 단순하게 푸는 예시 코드에서 TC 스스로 구해봤을때  n, k = 19, 1 처럼 주어졌을때 마지막에 1을 빼야 하는 부분을 
구현하는 것에서 보완이 필요헸다. 남은 수에 대햐여 1씩 빼는 부분까지 정확하게 구현하도록 하자. 

#### 이코테 page112
- dx ,dy를 설정할 때 좌표계가 영상처리에서 사용하는 좌표계 방식임을 잊지 말자! 
- move_types를 순서대로 지정해 놓고 nx, ny에 업데이트를 하는 코드 구현 방식 암기 + 각 for loop종료시 이동하는 것까지. (x, y = nx, ny)

#### 이코테 page114
- 문자열을 완전탐색하는 문제인데 중요한 것은 str() + str() 의 형식으로 문자열을 이어 붙일 수 있다는 것과 문자열을 'in' 키워드를 이용해서 특정
문자열 내에 내가 찾고자 하는 문자가 있는지 확인이 가능하다는 것을 기억하자!
```
n = int(input())
count = 0
for i in range(0, n+1):
  for j in range(0, 60):
    for k in range(0, 60):
      full = str(i) + str(j) + str(k) 
      if '3' in full:
        count += 1

print(count)
```
#### 이코테 page116
- 상하좌우 문제에서의 dx, dy를 여기서는 steps 변수를 이용해서 풀수도 있다. 
- 처음에 L 형태로 움직이기 때문에 어떻게 구현해야 할지 헷갈렸고, 체스판의 번호도 알파벳으로 되어 있어서 헷갈렸다. 하지만 **행 뿐만 아니라 열 또한 
인덱스로 바꿔줄 수만 있다면, steps에 각 움직이는 경우 별로 변화하는 좌표 값을 정의해 줄수만 있다면 해결 가능.** 결국에는 전체적으로
상하좌우 문제와 매우 유사하다. **아래 두 가지 부분이 막히는 부분이니 여기에 유의하자**

```
column = int(ord(input_data[0])) - int(ord('a')) + 1
```
```
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, -1), (2,1),(1,2),(-1,2),(-2,1)]

#8가지 방법에 대해 각 위치로 이동이 가능한지 확인
result = 0
for step in steps:
  # 이동하고자 하는 위치 확인
  next_row = row + step[0]
  next_column = column + step[1]
```
- 첫째 줄 설명
  - ord()는 하나의 문자에 대한 아스키 코드(ASCII Code) 정수 값을 반환합니다.
  - 열(column) 변수는 체스판의 가로축 인덱스를 의미합니다. 가로축은 a부터 h까지 존재하므로, 인덱스값을 계산하기 위해 'a'의 아스키코드 값만큼 빼주는 것입니다. 다만 이 문제에서는 인덱스가 1부터 출발하므로 추가적으로 1을 더해줍니다.

## [2/28]

#### 이코테 page118
- 전형적인 시뮬레이션 문제. 문제가 길고 문제를 바르게 이해하여 소스코드로 옮기는 과정이 간단치 않다. 따라서 이런 문제를 잘 풀 수 있도록 반복적인 숙달이 필요하다. 방향을 설정해서 이동하는 문제 유형의 경우 dx,dy 라는 별도의 리스트를 만들어 방향을 정하는 것이 효과적이다. 

##### 주의할 것
- **처음에 맵을 생성할 때 2차원 리스트를 0으로 초기화 하는 것 -> d = [[0] * m for _ in range(n)]**
- **방문 처리를 위해 리스트를 생성하는 것 -> d[x][y] = 1 # 현재 좌표 방문 처리**

#### 이코테 page151
- 다시 푸는 문제지만 dfs가 아니라 bfs인걸로 생각해서 풀어보려 했음. 
- dfs는 **재귀적으로 접근하는 방법**과 관련이 있음을 명심하자!
- 또한 2차원 리스트의 맵 정보, dfs(x,y)처럼 좌표를 받는다. 베이스 코드처럼 dfs(graph, start, visited) 처럼 쓰지 않는다!!
- 이전 문제와 다르게 따로 visited 리스트를 만들지 않는다!!

```
# 맵 정보 받을 때
graph = []
for i in range(n):
  graph.append(list(map(int, input())))
```

#### 이코테 page154
- 이 문제는 시뮬레이션(구현) 문제와 bfs문제가 짬뽕되어 있는 문제이다. 
- 상하좌우로 움직이는 문제이므로 dx, dy 리스트를 선언해야 하고, nx, ny를 업데이트해주는 코드가 필요하다. 맵을 벗어났을 경우의 예외 처리도 필요하며.
- 한편 가장 중요한 아이디어인 것 : 하나씩 방문하지 않은 위치를 찾아갈 때 해당 위치의 값을 단순히 1씩 증가시키는 것만으로도 최단 거리의 출력이 가능하다
- 단. 출력시 2차원리스트의 인덱스가 0부터 시작함에 유의하자
- 코딩 테스트 중 2차원 배열에서의 탐색 문제를 만난다면 그래프 형태로 바꿔서 생각하자. 맵을 그래프로 입력을 받아놓으라는 의미이다.

#### 이코테 page181
- sorted(array, key = lambda students : students[1]) 이 형태처럼 정렬을 할때 key라는 키워드와 무명함수를 이용하여 정렬을 내가 원하는 기준으로 할수있다.
```
# 입력받을때도 이렇게 처리하면 이름은 문자열 그래도, 점수는 정수형으로 변환하여 저장할수있다!
for i in range(n):
  input_data = input().split()
  array.append(input_data[0], int(input_data[1]))
 
# 이런식으로 써야 출력때 더 깔끔한것 같다
for students in array:
  print(student[0], end = ' ')
# 답 맞은 코드에서는 이렇게 썼음
for i in range(n):
  print(array[i][0], end = ' ')
```
#### 이코테 page196
- 데이터의 개수가 1000만 개를 넘어가거나 탐색 범위의 크기가 1000억 이상이라면 이진 탐색 알고리즘을 의심해 봐야 한다. 이때 다음을 이용하여 빠르게 입력받을 수 있다.
```
import sys
# 하나의 문자열 데이터 입력받기 
input_data = sys.stdin.readline().rstrip()
```
- rstrip() 함수를 꼭 호출해야 하는데, 왜냐하면 readline() 으로 입력하면 입력 후 엔터가 줄 바꿈 기호로 입력되기 때문이다. 이 공백 문자를 제거하기 위해서는 rstrip()함수를 사용해야 한다. 
 
 #### 이코테 page199 
 - 계수 정렬을 이용해서도 풀 수 있다! 계수정렬 소스코드에 익숙해지기(간단하므로 좋다)
 ```
 n =  int(input())
 array = [0] * 1000001
 
 # 가게에 있는 전체 부품 수를 입력받아서 기록
 for i in input().split():
  array[int(i)] = 1
 m = int(input())
 x = list(map(int, input().split())
 
 for i in x:
  if array[i] == 1:
    print('yes', end= ' ')
  else:
    print('no', end= ' ')
```
- 집합 자료형으로도 풀 수 있다. page200
