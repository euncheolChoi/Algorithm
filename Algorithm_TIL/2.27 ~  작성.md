#### [2/27] 이코테 page98

- 리스트의 원소 자체에 바로 min(), max()함수를 사용이 가능하다  
**예시**
```
for i in range(n):
  data = list(map(int, input().split()))
  min_value = 10001
  for a in data:
    min_value = min(min_value, a)
```
#### [2/27] 이코테 page101

- 단순하게 푸는 예시 코드에서 TC 스스로 구해봤을때  n, k = 19, 1 처럼 주어졌을때 마지막에 1을 빼야 하는 부분을 
구현하는 것에서 보완이 필요헸다. 남은 수에 대햐여 1씩 빼는 부분까지 정확하게 구현하도록 하자. 

#### [2/27] 이코테 page112
- dx ,dy를 설정할 때 좌표계가 영상처리에서 사용하는 좌표계 방식임을 잊지 말자! 
- move_types를 순서대로 지정해 놓고 nx, ny에 업데이트를 하는 코드 구현 방식 암기 + 각 for loop종료시 이동하는 것까지. (x, y = nx, ny)

#### [2/27] 이코테 page114
- 문자열을 완전탐색하는 문제인데 중요한 것은 str() + str() 의 형식으로 문자열을 이어 붙일 수 있다는 것과 문자열을 'in' 키워드를 이용해서 특정
문자열 내에 내가 찾고자 하는 문자가 있는지 확인이 가능하다는 것을 기억하자!
```
n = int(input())
count = 0
for i in range(0, n+1):
  for j in range(0, 60):
    for k in range(0, 60):
      full = str(i) + str(j) + str(k) 
      if '3' in full:
        count += 1

print(count)
```
#### [2/27] 이코테 page116
- 상하좌우 문제에서의 dx, dy를 여기서는 steps 변수를 이용해서 풀수도 있다. 
- 처음에 L 형태로 움직이기 때문에 어떻게 구현해야 할지 헷갈렸고, 체스판의 번호도 알파벳으로 되어 있어서 헷갈렸다. 하지만 **행 뿐만 아니라 열 또한 
인덱스로 바꿔줄 수만 있다면, steps에 각 움직이는 경우 별로 변화하는 좌표 값을 정의해 줄수만 있다면 해결 가능.** 결국에는 전체적으로
상하좌우 문제와 매우 유사하다. **아래 두 가지 부분이 막히는 부분이니 여기에 유의하자**

```
column = int(ord(input_data[0])) - int(ord('a')) + 1
```
```
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, -1), (2,1),(1,2),(-1,2),(-2,1)]

#8가지 방법에 대해 각 위치로 이동이 가능한지 확인
result = 0
for step in steps:
  # 이동하고자 하는 위치 확인
  next_row = row + step[0]
  next_column = column + step[1]
```
- 첫째 줄 설명
  - ord()는 하나의 문자에 대한 아스키 코드(ASCII Code) 정수 값을 반환합니다.
  - 열(column) 변수는 체스판의 가로축 인덱스를 의미합니다. 가로축은 a부터 h까지 존재하므로, 인덱스값을 계산하기 위해 'a'의 아스키코드 값만큼 빼주는 것입니다. 다만 이 문제에서는 인덱스가 1부터 출발하므로 추가적으로 1을 더해줍니다.
