## 3/04

#### 이코테 page248
```
def dijkstra(start):
  q = []
  # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
  heapq.heappush(q, (0, start))
  distance[start] = 0
  while q: # 큐가 비어있지 않다면
    # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
    dist, now = heapq.heappop(q)
    # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
    if distance[now] < dist:
      continue
    # 현재 노드와 연결된 다른 인접한 노드들을 확인 
    for i in graph[now]:
      cost = dist + i[1]  # graph 자체에 (b,c)가 원소로 들어가 있다. 즉 graph[now]의 i에는 (b,c)가 들어있으므로 i[1]이라면 c, 즉 비용을 의미한다
      # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
      if cost < distance[i[0]]:
        distance[i[0]] = cost
        heapq.heappush(q, (cost, i[0]))
```
- 위 코드에서 while 문 안을 보면 먼저 조건 검사를 하고, 방문하지 않았을 경우 최단 거리를 저장하는 리스트를 갱신하는 구조를 꼭 기억하자!

#### 이코테 page271 서로소 집합 자료구조
- <https://mosobamboo-dev.tistory.com/40> 소스코드에 제대로 이해한 부분을 주석으로 달았으니 꼭 확인 
- find_parent 함수는 루트를 찾아주는 함수임을 명심하자! (헷갈리니까..)
- 부모 테이블과 루트 테이블은 다르므로, 꼭 기억하고 소스코드를 보자
